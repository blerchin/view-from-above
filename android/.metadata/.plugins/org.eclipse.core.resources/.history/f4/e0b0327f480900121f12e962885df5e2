package com.example.time_lapse_camera;

import java.io.IOException;
import java.util.List;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.graphics.PixelFormat;
import android.hardware.Camera;
import android.os.Binder;
import android.os.Handler;
import android.os.IBinder;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.WindowManager;
import android.widget.Toast;

public class TimeLapsePictureTaker extends Service {
	private static String TAG = "TimeLapsePictureTaker";
	
	NotificationManager mNM;
	
	private static final Class<?>[] mSetForegroundSignature = new Class[] {
	    boolean.class};
	private static final Class<?>[] mStartForegroundSignature = new Class[] {
	    int.class, Notification.class};
	private static final Class<?>[] mStopForegroundSignature = new Class[] {
	    boolean.class};
	
	private Method mSetForeground;
	private Method mStartForeground;
	private Method mStopForeground;
	private Object[] mSetForegroundArgs = new Object[1];
	private Object[] mStartForegroundArgs = new Object[2];
	private Object[] mStopForegroundArgs = new Object[1];

	
	private CameraPreview cp;
	private WindowManager wm;
	private Camera mCamera;
	
	
	
	private Context ctx = this;
	
	//Unique TimeLapsePictureTakerID to start and cancel
	private int NOTIFICATION = R.string.picture_taker_started;
	
	/**
     * Class for clients to access.  Because we know this service always
     * runs in the same process as its clients, we don't need to deal with
     * IPC.
     */

	public class LocalBinder extends Binder {
        TimeLapsePictureTaker getService() {
            return TimeLapsePictureTaker.this;
        }
        	
        	
    }
	
	@Override
	public void onCreate() {
		initializeCameraPreview();
		
	}
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		Log.i("TimeLapsePictureTaker", "Received start id " + startId + ": " + intent);
		// We want this service to continue running until it is explicitly
        // stopped, so return sticky.
        return START_STICKY;
	}
	@Override
	public void onDestroy(){
		// remove overlaid view
		
		mCamera.setPreviewCallback(null);
		mCamera.stopPreview();
		
		mCamera.release();
		wm.removeView(cp);
		
		mNM.cancel(NOTIFICATION);
        // Tell the user we stopped.
        Toast.makeText(this, R.string.picture_taker_stopped, Toast.LENGTH_SHORT).show();
	}
	
	@Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }
	
	// This is the object that receives interactions from clients.  See
    // RemoteService for a more complete example.
    private final IBinder mBinder = new LocalBinder();

    /** A safe way to get an instance of the Camera object. */
    public static Camera getCameraInstance(){
        Camera c = null;
        try {
            c = Camera.open(); // attempt to get a Camera instance
        }
        catch (Exception e){
            // Camera is not available (in use or does not exist)
        }
        return c; // returns null if camera is unavailable
    }
    
    /**
     * Show a notification while this service is running.
     */
    private void showNotification() {
        // In this sample, we'll use the same text for the ticker and the expanded notification
        CharSequence text = getText(R.string.picture_taker_started);

        // Set the icon, scrolling text and timestamp
        Notification notification = new Notification(R.drawable.incoming_notification, text,
                System.currentTimeMillis());

        // The PendingIntent to launch our activity if the user selects this notification
        PendingIntent contentIntent = PendingIntent.getActivity(this, 0,
                new Intent(this, TakePicture.class), 0);

        // Set the info for the views that show in the notification panel.
        notification.setLatestEventInfo(this, "Time Lapse Picture Taker",
                       text, contentIntent);

        // Send the notification.
        mNM.notify(NOTIFICATION, notification);
    }
  public void initializeCameraPreview(){
	    mNM = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);

	    try{
		    mCamera = getCameraInstance();
		    cp = new CameraPreview(ctx,mCamera);
	    } catch (Exception e) {
	    	//if we can't get mCamera or the preview, probably the camera was just shut down
	    	//and needs to chill for a bit
	    	Log.d(TAG,"problem while setting up the camera; probably did not wait long enough after last shutdown");
	    }
	    
	    //Gnarly hack thanks to http://stackoverflow.com/questions/2386025/android-camera-without-preview
	    //Allows camera to be run as a persistent service even when screen is off (!!!)
	    
	    wm = (WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE);
	    WindowManager.LayoutParams params = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,
	                WindowManager.LayoutParams.WRAP_CONTENT,
	                WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY,
	                WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,
	                PixelFormat.TRANSLUCENT);
	   params.width = 0;
	   params.height = 0;
	   Log.d(TAG,"WindowManager created");
	   try{ 
	   wm.addView(cp, params);
	    Log.d(TAG,"View Added");
	    cp.init();
	   } catch (Exception e) {
		   Log.d(TAG,"issue while initializing CameraPreview");
	   }
	    SurfaceHolder mHolder = cp.getHolder();
	            
	    mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
	    mHolder.setFormat(PixelFormat.TRANSPARENT); 
	    
	    
	    try {
	    	mCamera.stopPreview();
	    	List<Camera.Size> previewSize = mCamera.getParameters().getSupportedPreviewSizes();
	    	Camera.Size maxPreviewSize = previewSize.get(previewSize.size() - 1);
	    	Log.d(TAG,"preview size set to "+maxPreviewSize.width+" x "+maxPreviewSize.height);		
	    	
	    	mCamera.getParameters().setPreviewSize(maxPreviewSize.width, maxPreviewSize.height);
	        mCamera.setPreviewDisplay(mHolder);
	        mCamera.startPreview();
	
	    } catch (Exception e) {
	        Log.d(TAG, "Error setting camera preview: " + e.getMessage());
	    } finally {
	    	showNotification();
	    	
	    }
	}
}
